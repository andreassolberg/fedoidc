



                                                         R. Hedberg, Ed.
                                                             independent
                                                           S. Gulliksson
                                                               Schibsted
                                                                M. Jones
                                                               Microsoft
                                                              J. Bradley
                                                           Ping Identity
                                                              A. Solberg
                                                                 Uninett
                                                      September 11, 2018


                OpenID Connect Federation 1.0 - draft 05
                      openid-connect-federation-05

Abstract

   The OpenID Connect standard specifies how a Relying Party (RP) can
   discover metadata about an OpenID Provider (OP), and then register to
   obtain relying party credentials.  The discovery and registration
   process does not involve any mechanisms of dynamically establishing
   trust in the exchanged information, but instead rely on-out-of band
   trust establishment.

   In an identity federation context, this is not sufficient.  The
   participants of the federation must be able to trust information
   provided about other participants in the federation.  OpenID Connect
   Federations specifies how trust can be dynamically obtained from
   resolving trust from a common trusted third party.

   While this specification is primarily targeting OpenID Connect, it is
   designed in order to allow for re-use by other protocols and in other
   use cases.

Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   2
     1.1.  Requirements Language . . . . . . . . . . . . . . . . . .   3
   2.  Entity Statement  . . . . . . . . . . . . . . . . . . . . . .   3
     2.1.  The trust anchor  . . . . . . . . . . . . . . . . . . . .   5
   3.  Metadata  . . . . . . . . . . . . . . . . . . . . . . . . . .   6
     3.1.  OpenID Connect Relying Party Metadata . . . . . . . . . .   6
     3.2.  OpenID Provider Metadata  . . . . . . . . . . . . . . . .   6
     3.3.  OpenID Connect Discovery  . . . . . . . . . . . . . . . .   7
     3.4.  OAuth Provider  . . . . . . . . . . . . . . . . . . . . .   7
     3.5.  OAuth Client  . . . . . . . . . . . . . . . . . . . . . .   7
     3.6.  OAuth Protected Resources . . . . . . . . . . . . . . . .   7



Hedberg, et al.          Expires March 15, 2019                 [Page 1]

                        OpenID Connect Federation         September 2018


   4.  Fetching entity statements  . . . . . . . . . . . . . . . . .   7
     4.1.  Using WebFinger to find the Metadata API endpoint . . . .   7
     4.2.  Querying the Metadata API endpoint  . . . . . . . . . . .   8
   5.  Resolving trust chain and metadata  . . . . . . . . . . . . .  10
     5.1.  Fetching entity statements to establish a trust chain . .  10
     5.2.  Finding trust chains  . . . . . . . . . . . . . . . . . .  10
     5.3.  Validating the trust chains . . . . . . . . . . . . . . .  10
     5.4.  Choosing one of the valid trust chains  . . . . . . . . .  11
     5.5.  Calculating the lifetime of a trust chain . . . . . . . .  11
   6.  Flattening compound metadata  . . . . . . . . . . . . . . . .  11
   7.  OpenID Connect Communication  . . . . . . . . . . . . . . . .  12
     7.1.  Explicit Registration . . . . . . . . . . . . . . . . . .  13
     7.2.  Implicit Registration . . . . . . . . . . . . . . . . . .  15
   8.  Timeouts  . . . . . . . . . . . . . . . . . . . . . . . . . .  15
   9.  Acknowledgements  . . . . . . . . . . . . . . . . . . . . . .  16
   10. IANA Considerations . . . . . . . . . . . . . . . . . . . . .  16
   11. Security Considerations . . . . . . . . . . . . . . . . . . .  16
   12. Normative References  . . . . . . . . . . . . . . . . . . . .  16
   Appendix A.  Illustrative Example . . . . . . . . . . . . . . . .  17
     A.1.  At the Beginning of Time  . . . . . . . . . . . . . . . .  17
     A.2.  A While Ago . . . . . . . . . . . . . . . . . . . . . . .  20
     A.3.  Recent  . . . . . . . . . . . . . . . . . . . . . . . . .  23
     A.4.  And Now for the Registration Request  . . . . . . . . . .  24
     A.5.  Foodle Relying Party Registration . . . . . . . . . . . .  26
     A.6.  Unpacking the Relying Party Registration Request  . . . .  29
     A.7.  Unpacked and Flattened Metadata Statement per FO  . . . .  29
   Appendix B.  UNUSED Metadata Statement  . . . . . . . . . . . . .  30
     B.1.  Compounded Metadata Statement . . . . . . . . . . . . . .  30
   Appendix C.  UNUSED Belonging to Several Federations  . . . . . .  32
     C.1.  Choosing a Federation . . . . . . . . . . . . . . . . . .  32
     C.2.  Relying Party . . . . . . . . . . . . . . . . . . . . . .  33
     C.3.  OpenID Provider . . . . . . . . . . . . . . . . . . . . .  34
   Appendix D.  UNUSED Trust Model . . . . . . . . . . . . . . . . .  34
     D.1.  Federation Operator . . . . . . . . . . . . . . . . . . .  35
     D.2.  The Building Block  . . . . . . . . . . . . . . . . . . .  35
     D.3.  Constructing a Signed Metadata Statement  . . . . . . . .  35
     D.4.  Verifying the Metadata Statement  . . . . . . . . . . . .  36
     D.5.  Flattening the Compounded Metadata Statement  . . . . . .  37
   Appendix E.  Open Issues  . . . . . . . . . . . . . . . . . . . .  38
   Appendix F.  Notices  . . . . . . . . . . . . . . . . . . . . . .  38
   Appendix G.  Document History . . . . . . . . . . . . . . . . . .  39
   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  39

1.  Introduction

   This specification describes how two entities that would like to
   interact can dynamically fetch and and resolve trust and metadata for
   a given protocol, by the use of third party trust issuers.



Hedberg, et al.          Expires March 15, 2019                 [Page 2]

                        OpenID Connect Federation         September 2018


   An identity federation can be realized using this specification by
   the use of one or more levels of trust issuers.  A trust issuer is a
   entity, which main purpose is to issue trust statements about OpenID
   consumers and providers.

   For an entity to take part in an Identity Federation, it must be
   accepted by an entity that is already member of the federation.  This
   other entity must be prepared to issue a entity statement describing
   the new member.  The new entity will typically configure a local
   trust root to include the identifier and the certificate of the
   trusted third party - the federation.  These two steps are usually
   sufficient for the entity to be able to interact with other entities
   in the federation, where metadata and trust is dynamically resolved.

   All entities involved in OpenID Connect Federation, including the
   trust issuers, will have their own unique identifier.  This
   identifier is used to dynamically fetch entity statements.  As a
   complete chain of entity statements is obtained, connecting the local
   trust root to the target entity, the entity may resolve the resulting
   trusted metadata, by flattening the metadata found in the trust
   chain.

   Note that a real-world entity like an organisation, a company may be
   represented by more the one entity in the federation.

   The OpenID Connect Federation trust chains are relying on
   cryptographically signed JWT documents, and the trust chain does not
   at all rely on TLS in order to establish trust.

   OpenID Connect Federation may very well be used for other purposes
   than building traditional identity federations.  One of them could be
   to build an OpenID Connect deployment where the key rollover process
   does not fall back to TLS.  Another could be allowing traditionally
   public/native clients, such as medical devices, to generate its own
   key pair, and use asymmetric crypto to increase the overall security.

1.1.  Requirements Language

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in RFC 2119 [RFC2119].

2.  Entity Statement

   An entity statement is always a signed JWT.  An entity statement is
   issued by the "iss", and the statement considers the subject entity,
   the "sub".  To be able to resolve trust and metadata, one need to
   know the identifier of the target entity - we refer to this as the



Hedberg, et al.          Expires March 15, 2019                 [Page 3]

                        OpenID Connect Federation         September 2018


   leaf entity.  The leaf entity will always sign a statement about
   itself, and give some hints to other entities that may want to issue
   statements about itself.  All other entities in a trust chain we
   refer to as intermediate entities.  The local configured trust root,
   we refer to as the trust anchor.

   iss  REQUIRED.  The entity identifier of the entity that issues the
      statement.  If the iss and the sub is identical, the issuer is
      making a statement about itself.

   sub  REQUIRED.  The entity identifier of the subject

   iat  REQUIRED.  The time the statement was issued.

   exp  REQUIRED.  The time the signed statement expires.

   jwks  REQUIRED.  A JSON Web Key Set (JWKS) [RFC7517] representing the
      public part of the subject entity's signing keys.

      These keys is used verify the identity of the subject.  A
      corresponding private key is used by the leaf entity to sign an
      entity statement about itself, and intermediate entities to sign
      statements about other entities.  The keys that can be found here
      is primarily intended to sign entity statements, and can not be
      used in other protocols, unless the metadata type specification
      explicitly states how the keys can be used.  In OpenID Connect,
      the jwks keys cannot be used within the
      Authorization/AccessToken/RefreshToken/UserInfo requests and
      responses.  Instead OpenID Connect specific metadata includes
      claims for this purpose.

   metadata  REQUIRED.  JSON object including protocol specific metadata
      claims that represent the leaf node.  To resolve the resulting
      metadata for a leaf node, the compound metadata documents included
      in the trust chain is merged by the metadata flattening process
      (Section 6).  The keys of the JSON object represent the metadata
      type identifier, and the value MUST be a JSON object representing
      the metadata according to the metadata scema of that metadata
      type.  To allow for the leaf node to resolve a specific metadata
      type, all intermediate entities in the trust chain MUST contain a
      metadata document for this specific type.  See section about
      metadata (Section 3).  An entity statement may contain multiple
      metadata statement, but only one for each metadata type.

   authorityHints  OPTIONAL.  A JSON list of identifiers of intermediate
      entities that may issue an entity statement about the issuer
      entity.  This list may be used in order to




Hedberg, et al.          Expires March 15, 2019                 [Page 4]

                        OpenID Connect Federation         September 2018


   The entity statement is signed using the private key of the issuer
   entity, in the form of a JSON Web Signature (JWS) [RFC7515].

   Non-normative example of a entity statement, before serialization and
   adding a signature.

   {
     "iss": "https://feide.no",
     "sub": "https://ntnu.no",
     "iat": 1516239022,
     "exp": 1516298022,
     "metadata": {
       "openid-provider": {
         "issuer": "https://ntnu.no",
         "organization": "NTNU",
         "id_token_signing_alg_values_supported": ["RS256", "RS384",
                                                   "RS512"]
       },
       "openid-client": {
         "organization": "NTNU",
         "grant_types_supported": ["authorization_code", "implicit"],
         "scopes": ["openid", "profile", "email", "phone"]
       }
     },
     "jwks": [
       {
         "alg": "RS256",
         "e": "AQAB",
         "ext": true,
         "key_ops": ["verify"],
         "kid": "key1",
         "kty": "RSA",
         "n": "pnXBOusEANuug6ewezb9J_...",
         "use": "sig"
       }
     ],
     "authorityHints": ["https://edugain.org/federation"]
   }

   (postamble)

2.1.  The trust anchor

   In order to configure trust when deploying a software component, it
   is recommended to align the configuration with the semantics of a
   entity statement.  How the configuration is stored and the exact
   format is out of the scope of this specification, but it is
   recommended to allow the user to configure a list of entries



Hedberg, et al.          Expires March 15, 2019                 [Page 5]

                        OpenID Connect Federation         September 2018


   containing "sub", "jwks " and "metadata".  When the compound metadata
   from the trust chain is resolved, metadata from the local trust root
   can be applied in the metadata flattening process (Section 6).  This
   allows the configuration of a provider to put trust limitations
   applied to all metadata resolved for the various trust roots.  In
   example, a provider may trust a large federation with a metadata
   limitation of only releasing the name and userid, and no other scopes
   or claims.  The provider may add other trust roots with a more
   limited target group to allow for more scopes and claims.

3.  Metadata

   The OpenID Connect Federations specification does allow new metadata
   types to be defined, to support use cases outside OpenID Connect.
   The metadata type identifier will uniquely identify which metadata
   specification to interpret.

   The metadata document MUST be a JSON document.  Beyound that there is
   no common

   Metadata used in OpenID Connect Federations typically re-use existing
   metadata standards.  If needed extend the metadata schema is extended
   with additional properties relevant in a federated context.

3.1.  OpenID Connect Relying Party Metadata

   The metadata type identifier is "openid-client".

   All parameters defined in section 2 of OpenID Connect Dynamic Client
   Registration 1.0 [OpenID.Registration] are allowed in a metadata
   statement.

   To that list is added:

   rp_scopes
      RECOMMENDED.  JSON array containing a list of the RFC6749
      [RFC6749] scope values that this relying party expects to use.

   rp_claims
      RECOMMENDED.  JSON array containing a list of the Claim Names of
      the Claims that the OpenID Client wants values for.

3.2.  OpenID Provider Metadata

   The metadata type identifier is "openid-"provider.

   All parameters defined in section 3 of OpenID Connect Discovery 1.0
   [OpenID.Discovery]



Hedberg, et al.          Expires March 15, 2019                 [Page 6]

                        OpenID Connect Federation         September 2018


   In addition the following properites are allowed:

   organizationName
      OPTIONAL.  A human readable name representing the organization
      owning the OpenID Provider.  It is intended to be used in the user
      interface, being reckognized for the end users that would be using
      the provider to authenticate.

3.3.  OpenID Connect Discovery

   The metadata type identifier is "openid-discovery".

3.4.  OAuth Provider

   The metadata type identifier is "openid-"provider.

3.5.  OAuth Client

   The metadata type identifier is "openid-client".

3.6.  OAuth Protected Resources

   The metadata type identifier is "openid-"api.

4.  Fetching entity statements

   In order to fetch entity statements, you need to know the identifier
   of the entity to ask, and the identifier of the entity that you want
   the statement to be about.  Typically you will start fetching entity
   statements before you initiate contact with another entity, where the
   identifier of this entity is all the information you have.  Then you
   will ask this identifier for entity statements about itself.

   Fetching entity statements is performed in two steps.  First
   WebFinger is used to resolve the entity statement API endpoint of the
   entity to ask.  Then the API endpoint is used to fetch one or more
   entity statements.

4.1.  Using WebFinger to find the Metadata API endpoint

   The entity is discovered using WebFinger [RFC7033], with the "rel"
   value: "https://openid.net/specs/federation/1.0/entity".  The
   "resouce" parameter is set the entity identifier from whom we would
   like to issue entity statements.

   The provider performs normalization rules to the entity identifier to
   determine the hostname.  In example the entity identifier




Hedberg, et al.          Expires March 15, 2019                 [Page 7]

                        OpenID Connect Federation         September 2018


   https://serviceprovider.org/application may result in the following
   WebFinger request:

   The following non-normative example is a WebFinger request to
   discover the Metadata API endpoint of the entity
   "https://serviceprovider.org/application".

   GET /.well-known/webfinger?
     resource=https%3A%2F%2Fserviceprovider.org%2Fapplication&
     rel=https%3A%2F%2Fopenid.net%2Fspecs%2Ffederation%2F1.0%2Fentity
     HTTP/1.1
   Host: serviceprovider.org

   (postamble)

   The response includes

   HTTP/1.1 200 OK
   Access-Control-Allow-Origin: *
   Content-Type: application/jrd+json

   {
     "subject" : "https://serviceprovider.org/application",
     "links" :
     [
       {
         "rel" : "https://openid.net/specs/federation/1.0/entity",
         "href" : "https://serviceprovider.org/metadata-api"
       }
     ]
   }

   (postamble)

4.2.  Querying the Metadata API endpoint

   Next, after the metadata API endpoint URL is resolved using
   WebFinger, the metadata API can be used to fetch entity statements
   about specific entities.  The metadata API endpoint may offer
   multiple services.

4.2.1.  Fetching Entity Statements

   The HTTP GET request to the metadata API endpoint takes the following
   query string parameters:

   target  REQUIRED.  The entity identifier of the target entity for
      which to issue metadata.



Hedberg, et al.          Expires March 15, 2019                 [Page 8]

                        OpenID Connect Federation         September 2018


   prefetch  OPTIONAL.  If left out, it is assumed to be "false".  If
      set to "true", it indicates that the requestor would like the API
      to prefetch entity statements that may be relevant.

   As long as the request is understood and correct, the response MUST
   be a JSON array including signed entity statements.  The content type
   MUST be set to "application/json".  If the issuing entity does not
   reckognize the target, it should return an empty JSON array.  The
   returned list of entity statements SHOULD include a statement issued
   by the issuing entity about the entity represented in the target
   parameter.  The issuing entity may also decide to prefetch additional
   entity statements that may be relevant to the requestor.

   The following is a non-normative example of an API request for entity
   statement:

   GET /metadata-api?target= HTTP/1.1
   Host: serviceprovider.org

   (postamble)

   resulting in the following response:

   200 OK
   Last-Modified: Wed, 22 Jul 2018 19:15:56 GMT
   Content-Type: application/json

   ["eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJodHRwczovL3Nlc..."]

   (the signed JWT is truntated)

4.2.2.  Trust negotiation

   TBD.  Resolving metadata for a specifc type of metadata, for a given
   peer.  The relying party may ask a specific provider to resolve the
   relying party openid-client metadata with its own configured trust
   root.  The result may tell what operations, scopes and claims the
   relying party is allowed to use.

4.2.3.  Entity listings

   TBD.  Return an JSON List of all entities that the entity may issue
   statements about.








Hedberg, et al.          Expires March 15, 2019                 [Page 9]

                        OpenID Connect Federation         September 2018


5.  Resolving trust chain and metadata

   An entity seeking to establish trust with a remote peer, will start
   with the knowledge of the remote peer entity identifier and with a
   locally configured trust anchor.  The entity will first have to fetch
   sufficient entity statements to establish a chain of trust from the
   remote peer to the locally configured trust anchor.  Afterwards the
   seeking entity will have to validate the trust chain, and choose one
   if there are multiple valid trust chains.

5.1.  Fetching entity statements to establish a trust chain

   The seeking entity should always start to ask the remote peer entity
   about its self-issued entity statement.  This entity statement MAY
   contain an list of intermediate entities in the authorityHints claim.

   The seeking entity may iterate through the list of authorityHints,
   and request entity statement on the remote peer from each of the
   intermediate.  It may further iterate intermediate entity statements
   for their authorityHints, and so on.  The seeking entity should never
   attempt to fetch entity statements it already have fetched in this
   process (loop prevention).

   The result of this operation should be a number of flat lists of
   entity statements.

5.2.  Finding trust chains

   The seeking entity will look for paths from the remote peer entity to
   the locally configured trust anchors.  If no path is found, the
   process of establishing trust has failed.  The result may also very
   well be more than one possible paths.

5.3.  Validating the trust chains

   A trust chain consists of a ordered list of entity statements that
   refer to each other from one entry in the local trust anchor to the
   self issued entity statement of the remote peer.

   We refer to the locally configured trust root as ES0, the top level
   intermediate entity statement as ES1, up to the self signed entity
   statement ESi.  A trust chain without any intermediate entities is
   also valid.  The trust anchor might include a ES0 representing a
   direct trust to a remote peer, and the self issued statement of the
   peer will then be ES1.

   To validate the chain, the signed JWT ES1 is validated against the
   public signing keys in ES0, jwks.  Next, the signed JWT ES2 is



Hedberg, et al.          Expires March 15, 2019                [Page 10]

                        OpenID Connect Federation         September 2018


   validated against the public signing keys in ES1, and so on until the
   complete chain is validated.

5.4.  Choosing one of the valid trust chains

   If multiple valid trust chain is found, the seeking entity will need
   to decide

5.5.  Calculating the lifetime of a trust chain

   Each entity statement in a trust chain is signed and MUST have a
   expiration time (exp) set.  Given that all of them are sometime in
   the future then the expiration time of the whole trust chain is then
   the expiration time that is closest in time to the present time.

6.  Flattening compound metadata

   The metadata for a specific entity can be constructed by starting
   with the information in ms_0 and then adding the information in ms_1
   to ms_n using the following rule:

   Given two metadata statements ms_i and ms_j (j > i, i=0, ..., n-1,
   j=1, ..., n) For every claim in ms_j: If the claim does not appear in
   ms_i add it to ms_i.  If the claim appears in ms_i then replace the
   value of the claim in ms_i with the value of the claim in ms_j if and
   only if the value in ms_j is a subset of the value in ms_i else an
   error MUST be generated.

   A subset is defined as:

   String
      One string is a subset of another string if it is exactly the
      same, byte by byte.

   Simple lists
      An array A is a subset of B if every element in A is also in B.

   Booleans
      Boolean A is a subset of B if A is equal to B.

   Integer/Floats
      The number A is a subset of the number B if A is less or equal to
      B.

   Associative array/dictionary
      A dictionary A is a subset of a dictionary B if every key in A is
      in B and the value of A[x] is a subset of B[x].




Hedberg, et al.          Expires March 15, 2019                [Page 11]

                        OpenID Connect Federation         September 2018


   The following is a non-normative example of a set of relying party-
   specific metadata statements that together form the metadata for an
   entity:

   ms_0

   {
     "contacts": ["helpdesk@example.com"],
     "logo_uri": "https://example.com/logo.jpg",
     "policy_uri": "https://example.com/policy.html",
     "tos_uri": "https://example.com/tos.html"
   }

   ms_1

   {
     "rp_scopes": ["openid", "eduperson"],
     "response_types": ["code", "code id_token"],
   }

   ms_2

   {
     "contacts": ["rp_helpdesk@example.com"],
     "redirect_uris": ["https://example.com/rp1"],
     "response_types: ["code"]
   }

   The metadata for the entity in question, using the rules above, would
   then be:

   sum(ms_0...2)

   {
     "contacts": ["helpdesk@example.com"],
     "logo_uri": "https://example.com/logo.jpg",
     "policy_uri": "https://example.com/policy.html",
     "tos_uri": "https://example.com/tos.html"
     "rp_scopes": ["openid", "eduperson"],
     "response_types": ["code"],
     "redirect_uris": ["https://example.com/rp1"],
   }

7.  OpenID Connect Communication

   The section describes how the trust framework in this specification
   is used to establish trust between an OpenID Relying Party and an
   OpenID Provider that has no explicit configuration or registration in



Hedberg, et al.          Expires March 15, 2019                [Page 12]

                        OpenID Connect Federation         September 2018


   advance.  The use of OpenID Connect Federation enables dynamically
   building large scale multi-lateral federations.

   There is two alternative approaches to establish trust between a
   Relying Party and a Provider.  Members of a federation or a community
   should agree upon which approach to use.  While implementations
   should support both methods, deployments may choose to disable the
   use of one of them.

7.1.  Explicit Registration

   This method involves performing an explicit registration of a new
   client the first time a Relying Party interacts with an OpenID
   Provider using something akin to OpenID Connect Dynamic Client
   Registration 1.0 [OpenID.Registration].

   It is assumed that an federation entity has a set of authorityHints
   and knowledge about which trust anchor that can be found at the end
   of a trust chain starting in each authorityHint.  How the entity has
   received this knowledge is outside the scope of this document.

7.1.1.  Provider Discovery

   The RP will start by figuring out the OPs metadata using the process
   specified in Resolving trust chain and metadata (Section 5) above.

7.1.2.  Client Registration

7.1.2.1.  Client Registration Request

   The OP MUST support dynamic relying party registration.  That it does
   so is signaled by have the claim "federation_registration_endpoint "
   in the metadata.

   Given that the OP supports dynamic registration the RP progresses as
   follows:

   1.  Once it has the list of acceptable trust chains for the OP it
       MUST choose the subset it wants to progress with.  The subset can
       be as small as one trust chain but it can also contain more then
       one.

   2.  Based on the trust anchors referenced in the subset of trust
       chains, the RP will choose a set of authorityHints from its own
       set that terminates in those trust anchors.

   3.  The RP will now construct a self-signed entity statement where
       the metadata statement chosen is influence by the OPs metadata



Hedberg, et al.          Expires March 15, 2019                [Page 13]

                        OpenID Connect Federation         September 2018


       and the authorityHints specified are picked by the process
       described above.

   4.  The entity statement is sent to the
       "federation_registration_endpoint " defined in this document.

7.1.2.2.  Client Registration Response

   Now of the OPs side the following occurs:

      It receives the request, collects and evaluates the trust chains
      starting with the authorityHints in the registration request.

      If it finds more then one acceptable trust chain it MUST chose one
      or more the terminates in one trust anchor.

      At this point if there already exists a client registration under
      the same entity_id then that MUST be regarded as invalid.

      The OP will now construct an entity statement containing a
      description of the RPs metadata that the OP finds acceptable.  To
      the entity statement it will add one or more authorityHints, from
      its collection, that terminates in the trust anchor chosen above.

      It will sign and return the signed entity statement to the RP

   Back at the RP it will:

      Verify the correctness of the received entity statement.  Making
      sure that the trust chains starting at the authorityHints
      terminates in trust anchors that where referenced in the entity
      statement it sent to the OP.

      If the RP is OK with the metadata that was the result of the
      flattening of the received entity statement then it store the
      configuration and can continue communicating with the OP.

      If the RP was not OK, for some reason, with the received entity
      statement then it has the choice to restart the registration
      process or to give up.

7.1.3.  After client registration

   A client registration using this specification is not expected to be
   valid for ever.  The entity statements exchanged both have expiration
   times set.  Which means that the registration will eventually time
   out.  To this can be added that the entities in the federation, for a




Hedberg, et al.          Expires March 15, 2019                [Page 14]

                        OpenID Connect Federation         September 2018


   number of reasons, over time may change how fast their signature will
   expires.

7.1.3.1.  What the RP MUST do

   At regular intervals the RP MUST:

      Starting with the OPs entity statement, resolve and verify the
      trust chains it chose to use when constructing the registration
      request.  If those trust chains don't exist anymore or do not
      verify then the registration should be regarded as invalid and a
      new registration process should be started.

      If the OPs entity statement was OK it must now verify that the
      entity statement about itself received from the OP is still valid.
      Again, if that is not the case the registration should be regarded
      as invalid and a new registration process should be started.

7.1.3.2.  What the OP MUST do

7.2.  Implicit Registration

   The trust between the entities is established using the above
   described extensions in the first two steps of the communication
   between an RP and an OP.  How the RP found the OP in the first place
   is out of scope for this document.

   ------                                       ------
   |    | <--- 1) Discovery -------->           |    |
   | RP | ---- 2) Authentication request -----> | OP |
   |    |                                       |    |
   ------                                       ------

   After the discovery and registration is completed a first time, those
   steps SHOULD only be repeated if any changes occur (see notes in
   respective sections below).

7.2.1.  The authentication request

8.  Timeouts

   There are a number of timeouts that MUST considered:

      Each signature has a timeout.

      A relying party registration has a timeout.





Hedberg, et al.          Expires March 15, 2019                [Page 15]

                        OpenID Connect Federation         September 2018


   Taking this into consideration, an OP MUST NOT assign a lifetime to a
   relying party registration that exceeds the lifetime of the metadata
   statement signatures.

9.  Acknowledgements

   o  Heather Flanagan

   o  The JRA3T3 task force of GEANT4-2

   o  Michael Schwartz

   o  Peter Schober

10.  IANA Considerations

   TBD

11.  Security Considerations

   TBD

12.  Normative References

   [OpenID.Core]
              Sakimura, N., Bradley, J., Jones, M., de Medeiros, B., and
              C. Mortimore, "OpenID Connect Discovery 1.0", August 2015,
              <http://openid.net/specs/openid-connect-core-1_0.html>.

   [OpenID.Discovery]
              Sakimura, N., Bradley, J., Jones, M., and E. Jay, "OpenID
              Connect Discovery 1.0", August 2015,
              <http://openid.net/specs/
              openid-connect-discovery-1_0.html>.

   [OpenID.Registration]
              Sakimura, N., Bradley, J., and M. Jones, "OpenID Connect
              Dynamic Client Registration 1.0", August 2015,
              <http://openid.net/specs/
              openid-connect-registration-1_0.html>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/info/rfc2119>.






Hedberg, et al.          Expires March 15, 2019                [Page 16]

                        OpenID Connect Federation         September 2018


   [RFC6749]  Hardt, D., Ed., "The OAuth 2.0 Authorization Framework",
              RFC 6749, DOI 10.17487/RFC6749, October 2012,
              <https://www.rfc-editor.org/info/rfc6749>.

   [RFC6962]  Laurie, B., Langley, A., and E. Kasper, "Certificate
              Transparency", RFC 6962, DOI 10.17487/RFC6962, June 2013,
              <https://www.rfc-editor.org/info/rfc6962>.

   [RFC7033]  Jones, P., Salgueiro, G., Jones, M., and J. Smarr,
              "WebFinger", RFC 7033, DOI 10.17487/RFC7033, September
              2013, <https://www.rfc-editor.org/info/rfc7033>.

   [RFC7515]  Jones, M., Bradley, J., and N. Sakimura, "JSON Web
              Signature (JWS)", RFC 7515, DOI 10.17487/RFC7515, May
              2015, <https://www.rfc-editor.org/info/rfc7515>.

   [RFC7517]  Jones, M., "JSON Web Key (JWK)", RFC 7517,
              DOI 10.17487/RFC7517, May 2015,
              <https://www.rfc-editor.org/info/rfc7517>.

Appendix A.  Illustrative Example

   The story is that the organization UNINETT has applied and been
   accepted as a member of two federations: Feide and SWAMID.

   Now UNINETT is running a service (Foodle) that needs signed metadata
   statements to prove that it belongs to the federation that the OP
   belongs to when a user of the Foodle service wants to log in using an
   OP that belongs to either or both of the federations.

A.1.  At the Beginning of Time

A.1.1.  SWAMID gets a key pair for signing Metadata Statements


















Hedberg, et al.          Expires March 15, 2019                [Page 17]

                        OpenID Connect Federation         September 2018


   {
     "keys": [
       {
         "d": "Ifr1DlW8kDIZxEvGgDQ7ei1mv0HWtF6K65krP3lj0N05aCM-zYZ5hcXp
   3B1MVfOfzAXu7YRB-XPadw_21OVDFokxAhoCT41h9h93grrlpWKn-ZhteQ6Z_bzmqD2o
   OyXwwMTd3nUXHTycllgE0nP4Z9gbZfw4cJ5yAr180PkM1any5HSSMnOZWdrXCr-NmE7V
   9uVPnTkZaaNxZX1A3e-ZPbfnfQPKrPDOUIOupFC3dANVakbSWi8Is2fLcIztHF-wKG7t
   AFNeh9nh-xLqWL6QCs11YRKwoHTtR_aVB0T7AtEMIv2QRiL6KmEVSqsxE4tWUz1RlY7m
   WQD624Ji6lkVUQ",
         "e": "AQAB",
         "kid": "65MJrFqCx0FR96K3qXrMgFV1918__TW7vuI2_LR_Ggo",
         "kty": "RSA",
         "n": "uFkG2IVbTtS7MaXFu7RRZ9or3rhrUZknEzTwTisOkb8Fi0I05mavWvKg
   J_3uyX_m5tLuAIB-wxjRpZhWxtUSG_ffuzvLqynZMsH4PMlDxX8RN91EtUu8C7ILX0-G
   t100NGYX8VsRMtlI1E942ZHlXmoJkel-L_b8V9Qfu810NBdNpDitHQf0ef38vutgPJrp
   Ad5RNTkqnh-xqC8jFAUfo41p4F42_XBG04E-79qHsqgzvOWealPJRuyM93ll2JVo2Vbh
   h5xHaCsvMnamFkaOmU1F2TN2dk3auRgaU2E8mwYP0UXqr1-elO-SoVQF7Q4CDpEihQtK
   8ilFpMGOGDLQhQ",
         "p": "12ytR2nfGJmBWq5tVUxWIGUus7k-zB-b5ieeH7hHQ6fGSMmWc7zCaLk1
   ej8Aq1YvN3ERF7dz6wCBUyDi0CtKyrypUT6ZMo2PUtDbWM84bRWEVbmLlzizYj2xJgtx
   1A25yKNROMdArj7jdsI--QRUIyWXFe9mYIwNK533Q-Ck0rU",
         "q": "2xHkocW04vzXrKcvFK8w0hckJcxy2eYF5RJCzERJ3lmqChT3wfcz875A
   ETa7ZxpoLp5giVONPUMxSToETl8SevlH6gQJPEFMyFnPcg1eRYL4Ec_2lYRnSFTrzKEb
   -_x-knDTuHIFHET2KqhnJZeiBF1Xl7nbD-uwgRIrk7BMmJE",
         "use": "sig"
       }
     ]
   }

A.1.2.  Feide gets a key pair for signing Metadata Statements





















Hedberg, et al.          Expires March 15, 2019                [Page 18]

                        OpenID Connect Federation         September 2018


   {
     "keys": [
       {
         "d": "FtiLOllu5-TRzhBZ6yI1fzIIGr6fE6kENP326-y5CccDPmo65qfy0s4L
   ggA37JHyYOdVKkvsSUYPC2Mjkhx-bO3wQH40pM4FDabIQSbPjSYhigmXTaC1CiV79BPB
   Ow3gKox0TvEXnZYTJiA33e6Ilm7YEGUEOyBB36751NLbhHfzU6NAjzLn6ATFK5LYVdAq
   ElViM1kOdG9pPlBV4kWlE5XWudr4cWWzXZ96yh5NnjBsbI0UXRIDRI4c10hfcxRCI1DK
   9DGOKE6AA5y8TkrK3W-7AAnu8tisqvPCplt_BwvVE7tIjxdst1CCcu2ahPuMOj5A2IV2
   IUnbxPr9mfuO4Q",
         "e": "AQAB",
         "kid": "IQ7LXNwXDGZwfAgjPGrKZRLuUzADOg4ll-LhVYCZhSw",
         "kty": "RSA",
         "n": "nxvB3L9cz1EtLS8VYBwXkesTCzUh0N72phLkHop0pwJR2yMp2BLPr2PN
   DCVnayJWWzHf0hvOHM4i3-In2P2dIx-7Zvzhy-9tvYWJdILmPj-i21a-XlvRv6KVN7oe
   zcNhi8lCymzRrr7mRuQYTC7jJF0UZylEAg25f4zpi0xg9x3DD6JgW6Z4m6mif7LA3wej
   JdF2nJy1qIj9vzpqDOxCbE59nI6hoSRAd36lfsv4v5zs5WLxu7fWnKed91slrUf9le4q
   W_KiaI8wvjQuzpnFQlnmJtYmD_45MAPi3f6-UkGFJAiLk3EHc7xgfe1Lv5bUMLMO9oyA
   kM7N4AaYulANpQ",
         "p": "xiupwierbdWasr8Zat-OXufPsRlZ0CJESIUl4YJ3X6hS_E0J370eY0IG
   NuePjn_A4-jMnRrX7jT37wiUWZtuATlg5DiH3DDjetSjpBd-fiH5e1Or5tqadmq0WgSk
   nZdhxtXzeVfM4d5uS2WMOi-h-9L4_4qOXjxhTNxDPK-rMeE",
         "q": "zYn03zyH0mbFLGwfRbm1RNq4DbT066xDUM127tqErpvG1Des5yaU0OIe
   1HfvUXWs6f6pVc0JmlqTtpf2KRN1LI8SgAXYflxg9vK7hSvu3oT4Ed9xXAfhVfocCmuX
   jve_YyC3S-_WLk8vtxQeyVwMc-7pCHF5C9Fz3IVgy7yXHEU",
         "use": "sig"
       }
     ]
   }

A.1.3.  UNINETT gets a key pair for signing Metadata Statements





















Hedberg, et al.          Expires March 15, 2019                [Page 19]

                        OpenID Connect Federation         September 2018


   {
     "keys": [
       {
         "d": "FtiLOllu5-TRzhBZ6yI1fzIIGr6fE6kENP326-y5CccDPmo65qfy0s4L
   ggA37JHyYOdVKkvsSUYPC2Mjkhx-bO3wQH40pM4FDabIQSbPjSYhigmXTaC1CiV79BPB
   Ow3gKox0TvEXnZYTJiA33e6Ilm7YEGUEOyBB36751NLbhHfzU6NAjzLn6ATFK5LYVdAq
   ElViM1kOdG9pPlBV4kWlE5XWudr4cWWzXZ96yh5NnjBsbI0UXRIDRI4c10hfcxRCI1DK
   9DGOKE6AA5y8TkrK3W-7AAnu8tisqvPCplt_BwvVE7tIjxdst1CCcu2ahPuMOj5A2IV2
   IUnbxPr9mfuO4Q",
         "e": "AQAB",
         "kid": "IQ7LXNwXDGZwfAgjPGrKZRLuUzADOg4ll-LhVYCZhSw",
         "kty": "RSA",
         "n": "nxvB3L9cz1EtLS8VYBwXkesTCzUh0N72phLkHop0pwJR2yMp2BLPr2PN
   DCVnayJWWzHf0hvOHM4i3-In2P2dIx-7Zvzhy-9tvYWJdILmPj-i21a-XlvRv6KVN7oe
   zcNhi8lCymzRrr7mRuQYTC7jJF0UZylEAg25f4zpi0xg9x3DD6JgW6Z4m6mif7LA3wej
   JdF2nJy1qIj9vzpqDOxCbE59nI6hoSRAd36lfsv4v5zs5WLxu7fWnKed91slrUf9le4q
   W_KiaI8wvjQuzpnFQlnmJtYmD_45MAPi3f6-UkGFJAiLk3EHc7xgfe1Lv5bUMLMO9oyA
   kM7N4AaYulANpQ",
         "p": "xiupwierbdWasr8Zat-OXufPsRlZ0CJESIUl4YJ3X6hS_E0J370eY0IG
   NuePjn_A4-jMnRrX7jT37wiUWZtuATlg5DiH3DDjetSjpBd-fiH5e1Or5tqadmq0WgSk
   nZdhxtXzeVfM4d5uS2WMOi-h-9L4_4qOXjxhTNxDPK-rMeE",
         "q": "zYn03zyH0mbFLGwfRbm1RNq4DbT066xDUM127tqErpvG1Des5yaU0OIe
   1HfvUXWs6f6pVc0JmlqTtpf2KRN1LI8SgAXYflxg9vK7hSvu3oT4Ed9xXAfhVfocCmuX
   jve_YyC3S-_WLk8vtxQeyVwMc-7pCHF5C9Fz3IVgy7yXHEU",
         "use": "sig"
       }
     ]
   }

A.2.  A While Ago

   Now is the time to construct the signed metadata statements and get
   them signed by the federations.  We'll start with Feide and UNINETT

A.2.1.  UNINETT constructs a signing request containing only the public
        parts of the UNINETT signing keys















Hedberg, et al.          Expires March 15, 2019                [Page 20]

                        OpenID Connect Federation         September 2018


   UNINETT Metadata Statement request

   {
     "federation_usage": "registration",
     "signing_keys": {
       "keys": [
         {
           "e": "AQAB",
           "kid": "5jl-7XNA-LaMiorIlf3qDdk35hbRaxnesdqzg1Q5rcg",
           "kty": "RSA",
           "n": "2NdTmzMa8pqiseO0tSHMmRiMUmeaFd1UC_-U0Irb-7DRPYLOv8DvUd
   IE069vnyDLZSi3Uio3H2E25W5sQpR7ieeGxr5l3XYWJgkiqmDikHnQwjtpFIO3Y_5gyH
   pBdqKHzYrqOh6aMdryFjZHjD_Pp5dh_-dnVR1jlwA3L3H_uXovC00beC30FPY88PrDYv
   _XCbmJiHmgAELyfgSvwIGqEzkn5Tw42O4EY_hPzVnMbGRLIzs-uyIjI2JLjhzgVP2AfP
   dT_s6GABKfVPkX6oCOtzzjmV_ca3_eOPfv1YICLeJry3JSVtHlqRzCCKl2dWPd-WcOL7
   IMUiAwxRWXd71omQ",
           "use": "sig"
         }
       ]
     }
   }

   UNINETT sends the Metadata statement signing request to Feide and
   Feide adds claims representing the Feide federation policy.

A.2.1.1.  Signed Metadata Statement Created by Feide

























Hedberg, et al.          Expires March 15, 2019                [Page 21]

                        OpenID Connect Federation         September 2018


   {
     "claims": [
       "sub",
       "name",
       "email",
       "picture"
     ],
     "exp": 1498636497,
     "federation_usage": "registration",
     "iat": 1496044497,
     "id_token_signing_alg_values_supported": [
       "RS256",
       "RS512"
     ],
     "iss": "https://www.feide.no",
     "jti": "357f54b78cd74df7aace917275dd3977",
     "kid": "IQ7LXNwXDGZwfAgjPGrKZRLuUzADOg4ll-LhVYCZhSw",
     "signing_keys": {
       "keys": [
         {
           "e": "AQAB",
           "kid": "5jl-7XNA-LaMiorIlf3qDdk35hbRaxnesdqzg1Q5rcg",
           "kty": "RSA",
           "n": "2NdTmzMa8pqiseO0tSHMmRiMUmeaFd1UC_-U0Irb-7DRPYLOv8DvUd
   IE069vnyDLZSi3Uio3H2E25W5sQpR7ieeGxr5l3XYWJgkiqmDikHnQwjtpFIO3Y_5gyH
   pBdqKHzYrqOh6aMdryFjZHjD_Pp5dh_-dnVR1jlwA3L3H_uXovC00beC30FPY88PrDYv
   _XCbmJiHmgAELyfgSvwIGqEzkn5Tw42O4EY_hPzVnMbGRLIzs-uyIjI2JLjhzgVP2AfP
   dT_s6GABKfVPkX6oCOtzzjmV_ca3_eOPfv1YICLeJry3JSVtHlqRzCCKl2dWPd-WcOL7
   IMUiAwxRWXd71omQ",
           "use": "sig"
         }
       ]
     }
   }

A.2.1.2.  The same process is repeated for UNINETT/SWAMID

   SUNET gets the same signing request as Feide got but adds a different
   set of policy claims.

A.2.1.2.1.  SWAMID Signed Metadata Statement










Hedberg, et al.          Expires March 15, 2019                [Page 22]

                        OpenID Connect Federation         September 2018


   {
     "exp": 1498636497,
     "federation_usage": "registration",
     "iat": 1496044497,
     "iss": "https://swamid.sunet.se/",
     "jti": "1c39646c40a145d4adab00ce6d42dabc",
     "kid": "65MJrFqCx0FR96K3qXrMgFV1918__TW7vuI2_LR_Ggo",
     "response_types": [
       "code",
       "token"
     ],
     "scopes": [
       "openid",
       "email"
     ],
     "signing_keys": {
       "keys": [
         {
           "e": "AQAB",
           "kid": "5jl-7XNA-LaMiorIlf3qDdk35hbRaxnesdqzg1Q5rcg",
           "kty": "RSA",
           "n": "2NdTmzMa8pqiseO0tSHMmRiMUmeaFd1UC_-U0Irb-7DRPYLOv8DvUd
   IE069vnyDLZSi3Uio3H2E25W5sQpR7ieeGxr5l3XYWJgkiqmDikHnQwjtpFIO3Y_5gyH
   pBdqKHzYrqOh6aMdryFjZHjD_Pp5dh_-dnVR1jlwA3L3H_uXovC00beC30FPY88PrDYv
   _XCbmJiHmgAELyfgSvwIGqEzkn5Tw42O4EY_hPzVnMbGRLIzs-uyIjI2JLjhzgVP2AfP
   dT_s6GABKfVPkX6oCOtzzjmV_ca3_eOPfv1YICLeJry3JSVtHlqRzCCKl2dWPd-WcOL7
   IMUiAwxRWXd71omQ",
           "use": "sig"
         }
       ]
     },
     "token_endpoint_auth_method": "private_key_jwt"
   }

A.2.2.  @UNINETT

   Now UNINETT sits with two signed metadata statements one for each of
   the federations it belongs to

A.3.  Recent

   Time to create the Foodle (RP) metadata statement.

   We take a road similar to the request/request_uri path.  That is, we
   include all the information about the relying party that needs to be
   protect from tampering by a MITM and places it in the metadata
   statement signing request.




Hedberg, et al.          Expires March 15, 2019                [Page 23]

                        OpenID Connect Federation         September 2018


   But first Foodle needs its own signing keys, not for signing Metadata
   Statements but for signing the JWKS document found at the URI pointed
   to by jwks_uri.  It is vital to protect this key information from
   tampering since a lot of the security of the future OIDC
   communication will depend on the correctness of the keys found at the
   jwks_uri.

   Foodle gets a key pair for signing the JWKS documents

   {
     "keys": [
       {
         "d": "WJp8QwwkLbf23G-8lkJMtimq2r9h7jom9Bjd3Rwonno39Wpi6DBPXSfY
   bPPKtzYl7GdlSMYV4ZPLOo3-wkUOT_mW7nm4oSLkR7TB9zJvSEdT1StMHi__Gu230Xhs
   La2ljZ8pxPeRfzwl2siKedwp1tKpSha-u49Z7Zw3pYq0KycWjJQ2v_1KOBqzRWK87Ytb
   _Wuo_TdFqo3H2EXvX0xDuJTRKBDQ7MRsM0vWNNAJHQDpOEIAZqeWYIoU2kmEioRpP15s
   OgL5N_tvkhG-e_W4jmh7SdJ89T2l8Ty54MY5an7mA6hBc_XDn7A6WI8nJnZVmpS3i0Is
   Uw85IAn6TspmIQ",
         "e": "AQAB",
         "kid": "MaBYxrj19OHpCjFAagAu0ltB8TmLsKqLBeqU1hsEeos",
         "kty": "RSA",
         "n": "0g592OMQDnwiaoVcstSTp8AACnd3z101qIES6PD6D4KPWcaDYE2QCM8L
   apwq7EOv3SfDGpcx0aNwQp0SaZstDZf5jiNBjfEou9CG8e1299_1mH7YV2JSjrtiyNia
   JyI4Va-JzIYBUouybF8GgTD3nnjVVYf9gKFoUf6kHTYPiblM44c43u55wC5oAxdMvkK7
   eAVkGFzLWLIEnkLtxIXc-Naxurl01zJfnH7dLfpcATN4uV9inI1vAnP9Lyg0RsSSoa3X
   cuKDsTBs5Fm1wLyQm0KVhus2tNMLMfoNMZOcmrhycaOEymo7FaayLgTWqjOv9-bIaw3H
   QvJ-OmJSxSohkw",
         "p": "3W1eZKJtxy5tdbtuSxbYFJvVJoOvYZw91XGPcbMz1cbkJZN60h4_709y
   Z72TEyojO-Ch-CBdgqgHdR2BBjZGESdH1FOYrQxgYsiKz1FlHW5h79fsqe3cn2JAwoEx
   U1jTwuGPanAQArnRsfxnjZIcJ9aUlfaVf-MbfljBolZPIgc",
         "q": "8tqhQpVw7x7p68v0_vv7Uz-KFUVBjlEvJu6jfFDHBF8-zTqGhpe1H-Jw
   t_YRlm8thINKUbKaQy3uiZWTe_baHSHexi72-1NQNdd9Ztha2l_NHDKp4d24Mo3f72cT
   egkaudZAuo8uoAblK2DBZ5CmszO1rFyZQBpHRfjvh91PMRU",
         "use": "sig"
       }
     ]
   }

A.4.  And Now for the Registration Request

   Client Registration request

   {
     "application_type": "web",
     "response_types": [
       "code"
     ]
   }



Hedberg, et al.          Expires March 15, 2019                [Page 24]

                        OpenID Connect Federation         September 2018


   The Client Registration Request is sent to UNINETT who adds the two
   signed metadata statements it has.  One for each of SWAMID and Feide.
   Since it knows that it is the Foodle RP which is the subject of the
   JWT it adds Foodle's identifier as 'sub'.

A.4.1.  Metadata Statements about Foodle signed by UNINETT

   With SWAMID as Federation operator:

   {
     "application_type": "web",
     "exp": 1496130898,
     "iat": 1496044498,
     "iss": "https://www.uninett.no",
     "kid": "5jl-7XNA-LaMiorIlf3qDdk35hbRaxnesdqzg1Q5rcg",
     "metadata_statements": {
       "https://swamid.sunet.se/": "eyJhbGciOiJSUzI1NiIsImtpZCI6IjY1TUp
   yRnFDeDBGUjk2SzNxWHJNZ0ZWMTkxOF9fVFc3dnVJMl9MUl9HZ28ifQ.eyJmZWRlcmF0
   aW9uX3VzYWdlIjogInJlZ2lzdHJhdGlvbiIsICJzaWduaW5nX2tleXMiOiB7ImtleXMi
   OiBbeyJrdHkiOiAiUlNBIiwgInVzZSI6ICJzaWciLCAia2lkIjogIjVqbC03WE5BLUxh
   TWlvcklsZjNxRGRrMzVoYlJheG5lc2RxemcxUTVyY2ciLCAibiI6ICIyTmRUbXpNYThw
   cWlzZU8wdFNITW1SaU1VbWVhRmQxVUNfLVUwSXJiLTdEUlBZTE92OER2VWRJRTA2OXZu
   eURMWlNpM1VpbzNIMkUyNVc1c1FwUjdpZWVHeHI1bDNYWVdKZ2tpcW1EaWtIblF3anRw
   RklPM1lfNWd5SHBCZHFLSHpZcnFPaDZhTWRyeUZqWkhqRF9QcDVkaF8tZG5WUjFqbHdB
   M0wzSF91WG92QzAwYmVDMzBGUFk4OFByRFl2X1hDYm1KaUhtZ0FFTHlmZ1N2d0lHcUV6
   a241VHc0Mk80RVlfaFB6Vm5NYkdSTEl6cy11eUlqSTJKTGpoemdWUDJBZlBkVF9zNkdB
   QktmVlBrWDZvQ090enpqbVZfY2EzX2VPUGZ2MVlJQ0xlSnJ5M0pTVnRIbHFSekNDS2wy
   ZFdQZC1XY09MN0lNVWlBd3hSV1hkNzFvbVEiLCAiZSI6ICJBUUFCIn1dfSwgInJlc3Bv
   bnNlX3R5cGVzIjogWyJjb2RlIiwgInRva2VuIl0sICJ0b2tlbl9lbmRwb2ludF9hdXRo
   X21ldGhvZCI6ICJwcml2YXRlX2tleV9qd3QiLCAic2NvcGVzIjogWyJvcGVuaWQiLCAi
   ZW1haWwiXSwgImlzcyI6ICJodHRwczovL3N3YW1pZC5zdW5ldC5zZS8iLCAiaWF0Ijog
   MTQ5NjA0NDQ5NywgImV4cCI6IDE0OTg2MzY0OTcsICJraWQiOiAiNjVNSnJGcUN4MEZS
   OTZLM3FYck1nRlYxOTE4X19UVzd2dUkyX0xSX0dnbyIsICJqdGkiOiAiMWMzOTY0NmM0
   MGExNDVkNGFkYWIwMGNlNmQ0MmRhYmMifQ.YPcpHSluei_DbOyRxDQ9PeL5FU23ZHU45
   G33WTJlCT1QxqzKLYFjHdm28WVHxquQ4FrgmY49Wt9vm1cvsg5hSyxNcHJMDDL3Y4pfe
   LeozTVZhDrx-wUCcPqCIxpU9WdtuWvefyvxzbuF8qMf7_4Aiw8V1TqJc7tqYpd_Ic0xd
   uHEMFaF1UATztdGOKy4iISSR6qKOKGfJyW4IlNw-hLR5DImln4W7uikHFUxkKjmrXCQ-
   AnKhMUub75dThKg-vIZiXD8T0KbIsi2l40bH_n9qWexnpX_BAGvCgY9LlEJ0Z8wlTpHq
   HzD2mrs218ysop2tB45ICJpsW_YDqWHgvP9mQ"
     },
     "response_types": [
       "code"
     ],
     "sub": "https://foodle.uninett.no"
   }

   With Feide as Federation operator




Hedberg, et al.          Expires March 15, 2019                [Page 25]

                        OpenID Connect Federation         September 2018


   {
     "application_type": "web",
     "exp": 1496130898,
     "iat": 1496044498,
     "iss": "https://www.uninett.no",
     "kid": "5jl-7XNA-LaMiorIlf3qDdk35hbRaxnesdqzg1Q5rcg",
     "metadata_statements": {
       "https://www.feide.no": "eyJhbGciOiJSUzI1NiIsImtpZCI6IklRN0xYTnd
   YREdad2ZBZ2pQR3JLWlJMdVV6QURPZzRsbC1MaFZZQ1poU3cifQ.eyJmZWRlcmF0aW9u
   X3VzYWdlIjogInJlZ2lzdHJhdGlvbiIsICJzaWduaW5nX2tleXMiOiB7ImtleXMiOiBb
   eyJrdHkiOiAiUlNBIiwgInVzZSI6ICJzaWciLCAia2lkIjogIjVqbC03WE5BLUxhTWlv
   cklsZjNxRGRrMzVoYlJheG5lc2RxemcxUTVyY2ciLCAibiI6ICIyTmRUbXpNYThwcWlz
   ZU8wdFNITW1SaU1VbWVhRmQxVUNfLVUwSXJiLTdEUlBZTE92OER2VWRJRTA2OXZueURM
   WlNpM1VpbzNIMkUyNVc1c1FwUjdpZWVHeHI1bDNYWVdKZ2tpcW1EaWtIblF3anRwRklP
   M1lfNWd5SHBCZHFLSHpZcnFPaDZhTWRyeUZqWkhqRF9QcDVkaF8tZG5WUjFqbHdBM0wz
   SF91WG92QzAwYmVDMzBGUFk4OFByRFl2X1hDYm1KaUhtZ0FFTHlmZ1N2d0lHcUV6a241
   VHc0Mk80RVlfaFB6Vm5NYkdSTEl6cy11eUlqSTJKTGpoemdWUDJBZlBkVF9zNkdBQktm
   VlBrWDZvQ090enpqbVZfY2EzX2VPUGZ2MVlJQ0xlSnJ5M0pTVnRIbHFSekNDS2wyZFdQ
   ZC1XY09MN0lNVWlBd3hSV1hkNzFvbVEiLCAiZSI6ICJBUUFCIn1dfSwgImlkX3Rva2Vu
   X3NpZ25pbmdfYWxnX3ZhbHVlc19zdXBwb3J0ZWQiOiBbIlJTMjU2IiwgIlJTNTEyIl0s
   ICJjbGFpbXMiOiBbInN1YiIsICJuYW1lIiwgImVtYWlsIiwgInBpY3R1cmUiXSwgImlz
   cyI6ICJodHRwczovL3d3dy5mZWlkZS5ubyIsICJpYXQiOiAxNDk2MDQ0NDk3LCAiZXhw
   IjogMTQ5ODYzNjQ5NywgImtpZCI6ICJJUTdMWE53WERHWndmQWdqUEdyS1pSTHVVekFE
   T2c0bGwtTGhWWUNaaFN3IiwgImp0aSI6ICIzNTdmNTRiNzhjZDc0ZGY3YWFjZTkxNzI3
   NWRkMzk3NyJ9.KgkrB2CuT_WImSAQfA-ioNDE5SeGN9pZSpwcvzrCadCQNxbx2f2s8Jm
   5Nw39kuls2FBeyjeSk25vpkx05cJdy5KULLWQU9HHRjd6tAzS8JjAjNnrs8b2i90UqWl
   Sv8yY5jGVZYxhYYo21ea9kxTRK2F4ELQWGm6EDJoiyvAww4irwPwBqczQujMx2KWbVoS
   _yLcATwW3PYANhCGhdZ0FWDYhCl_P4MbdUkporMxxFyEDv9lsbsuzW8N17Afw_AxXOF-
   G_ZZymugFm73xDZJCGFwqoVQvij_I_xnIbjFQzvm9p-Y7NQm8Am40sh6QzGQX7U9mMjz
   eUKCTlK6eW2WuBQ"
     },
     "response_types": [
       "code"
     ],
     "sub": "https://foodle.uninett.no"
   }

A.5.  Foodle Relying Party Registration

   Now, when Foodle wants to register as a relying party with an OP it
   adds the signed Metadata statement it received from UNINETT to the
   relying party registration request.  Note that 'redirect_uri' MUST be
   in the registration request as this is required by the OIDC standard.
   If the 'redirect_uris' values that are transferred unprotected were
   to differ from what's in the signed metadata statement, the OP MUST
   refuse the registration.

   Registration Request published by RP



Hedberg, et al.          Expires March 15, 2019                [Page 26]

                        OpenID Connect Federation         September 2018


   {
     "metadata_statements": {
       "https://swamid.sunet.se/": "eyJhbGciOiJSUzI1NiIsImtpZCI6IjVqbC0
   3WE5BLUxhTWlvcklsZjNxRGRrMzVoYlJheG5lc2RxemcxUTVyY2cifQ.eyJhcHBsaWNh
   dGlvbl90eXBlIjogIndlYiIsICJyZXNwb25zZV90eXBlcyI6IFsiY29kZSJdLCAibWV0
   YWRhdGFfc3RhdGVtZW50cyI6IHsiaHR0cHM6Ly9zd2FtaWQuc3VuZXQuc2UvIjogImV5
   SmhiR2NpT2lKU1V6STFOaUlzSW10cFpDSTZJalkxVFVweVJuRkRlREJHVWprMlN6TnhX
   SEpOWjBaV01Ua3hPRjlmVkZjM2RuVkpNbDlNVWw5SFoyOGlmUS5leUptWldSbGNtRjBh
   Vzl1WDNWellXZGxJam9nSW5KbFoybHpkSEpoZEdsdmJpSXNJQ0p6YVdkdWFXNW5YMnRs
   ZVhNaU9pQjdJbXRsZVhNaU9pQmJleUpyZEhraU9pQWlVbE5CSWl3Z0luVnpaU0k2SUNK
   emFXY2lMQ0FpYTJsa0lqb2dJalZxYkMwM1dFNUJMVXhoVFdsdmNrbHNaak54UkdSck16
   Vm9ZbEpoZUc1bGMyUnhlbWN4VVRWeVkyY2lMQ0FpYmlJNklDSXlUbVJVYlhwTllUaHdj
   V2x6WlU4d2RGTklUVzFTYVUxVmJXVmhSbVF4VlVOZkxWVXdTWEppTFRkRVVsQlpURTky
   T0VSMlZXUkpSVEEyT1hadWVVUk1XbE5wTTFWcGJ6TklNa1V5TlZjMWMxRndVamRwWldW
   SGVISTFiRE5ZV1ZkS1oydHBjVzFFYVd0SWJsRjNhblJ3UmtsUE0xbGZOV2Q1U0hCQ1pI
   RkxTSHBaY25GUGFEWmhUV1J5ZVVacVdraHFSRjlRY0RWa2FGOHRaRzVXVWpGcWJIZEJN
   MHd6U0Y5MVdHOTJRekF3WW1WRE16QkdVRms0T0ZCeVJGbDJYMWhEWW0xS2FVaHRaMEZG
   VEhsbVoxTjJkMGxIY1VWNmEyNDFWSGMwTWs4MFJWbGZhRkI2Vm01TllrZFNURWw2Y3kx
   MWVVbHFTVEpLVEdwb2VtZFdVREpCWmxCa1ZGOXpOa2RCUWt0bVZsQnJXRFp2UTA5MGVu
   cHFiVlpmWTJFelgyVlBVR1oyTVZsSlEweGxTbko1TTBwVFZuUkliSEZTZWtORFMyd3la
   RmRRWkMxWFkwOU1OMGxOVldsQmQzaFNWMWhrTnpGdmJWRWlMQ0FpWlNJNklDSkJVVUZD
   SW4xZGZTd2dJbkpsYzNCdmJuTmxYM1I1Y0dWeklqb2dXeUpqYjJSbElpd2dJblJ2YTJW
   dUlsMHNJQ0owYjJ0bGJsOWxibVJ3YjJsdWRGOWhkWFJvWDIxbGRHaHZaQ0k2SUNKd2Nt
   bDJZWFJsWDJ0bGVWOXFkM1FpTENBaWMyTnZjR1Z6SWpvZ1d5SnZjR1Z1YVdRaUxDQWla
   VzFoYVd3aVhTd2dJbWx6Y3lJNklDSm9kSFJ3Y3pvdkwzTjNZVzFwWkM1emRXNWxkQzV6
   WlM4aUxDQWlhV0YwSWpvZ01UUTVOakEwTkRRNU55d2dJbVY0Y0NJNklERTBPVGcyTXpZ
   ME9UY3NJQ0pyYVdRaU9pQWlOalZOU25KR2NVTjRNRVpTT1RaTE0zRlljazFuUmxZeE9U
   RTRYMTlVVnpkMmRVa3lYMHhTWDBkbmJ5SXNJQ0pxZEdraU9pQWlNV016T1RZME5tTTBN
   R0V4TkRWa05HRmtZV0l3TUdObE5tUTBNbVJoWW1NaWZRLllQY3BIU2x1ZWlfRGJPeVJ4
   RFE5UGVMNUZVMjNaSFU0NUczM1dUSmxDVDFReHF6S0xZRmpIZG0yOFdWSHhxdVE0RnJn
   bVk0OVd0OXZtMWN2c2c1aFN5eE5jSEpNRERMM1k0cGZlTGVvelRWWmhEcngtd1VDY1Bx
   Q0l4cFU5V2R0dVd2ZWZ5dnh6YnVGOHFNZjdfNEFpdzhWMVRxSmM3dHFZcGRfSWMweGR1
   SEVNRmFGMVVBVHp0ZEdPS3k0aUlTU1I2cUtPS0dmSnlXNElsTnctaExSNURJbWxuNFc3
   dWlrSEZVeGtLam1yWENRLUFuS2hNVXViNzVkVGhLZy12SVppWEQ4VDBLYklzaTJsNDBi
   SF9uOXFXZXhucFhfQkFHdkNnWTlMbEVKMFo4d2xUcEhxSHpEMm1yczIxOHlzb3AydEI0
   NUlDSnBzV19ZRHFXSGd2UDltUSJ9LCAiaXNzIjogImh0dHBzOi8vd3d3LnVuaW5ldHQu
   bm8iLCAiaWF0IjogMTQ5NjA0NDQ5OCwgImV4cCI6IDE0OTYxMzA4OTgsICJraWQiOiAi
   NWpsLTdYTkEtTGFNaW9ySWxmM3FEZGszNWhiUmF4bmVzZHF6ZzFRNXJjZyIsICJzdWIi
   OiAiaHR0cHM6Ly9mb29kbGUudW5pbmV0dC5ubyJ9.ioRfk8nzESbwhbLig_VwzqelgaP
   m01jQ5LGg1i2FYjgb7MiFkITb9JTeXjZ5H-HBDIBd2-CByL9L8W_XrFS-wuZovVudV3Z
   blkwVGFTqkzHHGrN385Jh3GHRJORH87SkF2GJ-ZOUP1TXQ3NXT7IXhi75AsYaUDa6E5t
   sCPyQ39XuHPIAR6ACkVAeEUiWnx8Yg5Ryf9pkAYhcQjTYq50uF6lENiqCF2mWlBmVcN8
   83P9gjz8iXZYnlBsKr8LY5SnLD3ljU8XXDCl4J616E0dPIucgUMxnWCaMmUv9gOSZ1wQ
   fjD36sk9_KQ7Ei-JItSGzqElfSyhFS7cWORCdINs4-w",
       "https://www.feide.no": "eyJhbGciOiJSUzI1NiIsImtpZCI6IjVqbC03WE5
   BLUxhTWlvcklsZjNxRGRrMzVoYlJheG5lc2RxemcxUTVyY2cifQ.eyJhcHBsaWNhdGlv
   bl90eXBlIjogIndlYiIsICJyZXNwb25zZV90eXBlcyI6IFsiY29kZSJdLCAibWV0YWRh
   dGFfc3RhdGVtZW50cyI6IHsiaHR0cHM6Ly93d3cuZmVpZGUubm8iOiAiZXlKaGJHY2lP



Hedberg, et al.          Expires March 15, 2019                [Page 27]

                        OpenID Connect Federation         September 2018


   aUpTVXpJMU5pSXNJbXRwWkNJNklrbFJOMHhZVG5kWVJFZGFkMlpCWjJwUVIzSkxXbEpN
   ZFZWNlFVUlBaelJzYkMxTWFGWlpRMXBvVTNjaWZRLmV5Sm1aV1JsY21GMGFXOXVYM1Z6
   WVdkbElqb2dJbkpsWjJsemRISmhkR2x2YmlJc0lDSnphV2R1YVc1blgydGxlWE1pT2lC
   N0ltdGxlWE1pT2lCYmV5SnJkSGtpT2lBaVVsTkJJaXdnSW5WelpTSTZJQ0p6YVdjaUxD
   QWlhMmxrSWpvZ0lqVnFiQzAzV0U1QkxVeGhUV2x2Y2tsc1pqTnhSR1JyTXpWb1lsSmhl
   RzVsYzJSeGVtY3hVVFZ5WTJjaUxDQWliaUk2SUNJeVRtUlViWHBOWVRod2NXbHpaVTh3
   ZEZOSVRXMVNhVTFWYldWaFJtUXhWVU5mTFZVd1NYSmlMVGRFVWxCWlRFOTJPRVIyVldS
   SlJUQTJPWFp1ZVVSTVdsTnBNMVZwYnpOSU1rVXlOVmMxYzFGd1VqZHBaV1ZIZUhJMWJE
   TllXVmRLWjJ0cGNXMUVhV3RJYmxGM2FuUndSa2xQTTFsZk5XZDVTSEJDWkhGTFNIcFpj
   bkZQYURaaFRXUnllVVpxV2tocVJGOVFjRFZrYUY4dFpHNVdVakZxYkhkQk0wd3pTRjkx
   V0c5MlF6QXdZbVZETXpCR1VGazRPRkJ5UkZsMlgxaERZbTFLYVVodFowRkZUSGxtWjFO
   MmQwbEhjVVY2YTI0MVZIYzBNazgwUlZsZmFGQjZWbTVOWWtkU1RFbDZjeTExZVVscVNU
   SktUR3BvZW1kV1VESkJabEJrVkY5ek5rZEJRa3RtVmxCcldEWnZRMDkwZW5wcWJWWmZZ
   MkV6WDJWUFVHWjJNVmxKUTB4bFNuSjVNMHBUVm5SSWJIRlNla05EUzJ3eVpGZFFaQzFY
   WTA5TU4wbE5WV2xCZDNoU1YxaGtOekZ2YlZFaUxDQWlaU0k2SUNKQlVVRkNJbjFkZlN3
   Z0ltbGtYM1J2YTJWdVgzTnBaMjVwYm1kZllXeG5YM1poYkhWbGMxOXpkWEJ3YjNKMFpX
   UWlPaUJiSWxKVE1qVTJJaXdnSWxKVE5URXlJbDBzSUNKamJHRnBiWE1pT2lCYkluTjFZ
   aUlzSUNKdVlXMWxJaXdnSW1WdFlXbHNJaXdnSW5CcFkzUjFjbVVpWFN3Z0ltbHpjeUk2
   SUNKb2RIUndjem92TDNkM2R5NW1aV2xrWlM1dWJ5SXNJQ0pwWVhRaU9pQXhORGsyTURR
   ME5EazNMQ0FpWlhod0lqb2dNVFE1T0RZek5qUTVOeXdnSW10cFpDSTZJQ0pKVVRkTVdF
   NTNXRVJIV25kbVFXZHFVRWR5UzFwU1RIVlZla0ZFVDJjMGJHd3RUR2hXV1VOYWFGTjNJ
   aXdnSW1wMGFTSTZJQ0l6TlRkbU5UUmlOemhqWkRjMFpHWTNZV0ZqWlRreE56STNOV1Jr
   TXprM055SjkuS2drckIyQ3VUX1dJbVNBUWZBLWlvTkRFNVNlR045cFpTcHdjdnpyQ2Fk
   Q1FOeGJ4MmYyczhKbTVOdzM5a3VsczJGQmV5amVTazI1dnBreDA1Y0pkeTVLVUxMV1FV
   OUhIUmpkNnRBelM4SmpBak5ucnM4YjJpOTBVcVdsU3Y4eVk1akdWWll4aFlZbzIxZWE5
   a3hUUksyRjRFTFFXR202RURKb2l5dkF3dzRpcndQd0JxY3pRdWpNeDJLV2JWb1NfeUxj
   QVR3VzNQWUFOaENHaGRaMEZXRFloQ2xfUDRNYmRVa3Bvck14eEZ5RUR2OWxzYnN1elc4
   TjE3QWZ3X0F4WE9GLUdfWlp5bXVnRm03M3hEWkpDR0Z3cW9WUXZpal9JX3huSWJqRlF6
   dm05cC1ZN05RbThBbTQwc2g2UXpHUVg3VTltTWp6ZVVLQ1RsSzZlVzJXdUJRIn0sICJp
   c3MiOiAiaHR0cHM6Ly93d3cudW5pbmV0dC5ubyIsICJpYXQiOiAxNDk2MDQ0NDk4LCAi
   ZXhwIjogMTQ5NjEzMDg5OCwgImtpZCI6ICI1amwtN1hOQS1MYU1pb3JJbGYzcURkazM1
   aGJSYXhuZXNkcXpnMVE1cmNnIiwgInN1YiI6ICJodHRwczovL2Zvb2RsZS51bmluZXR0
   Lm5vIn0.FTG1ydN7uGa1J6ZZjs9xgPgtPd_cJuIyrXrfo7WT6q3IdPvziNpeWDCcimKD
   tM8AGNMwNnr6LFkCwmwkxcKn9Aua6mmq9HaqtfIcauA8GOnKN3sK2he2NfuHF3JGGkjP
   dcQ-JgIv50FrZ7M07HeQgn7gLGqv9sjWbuysMyO8LHKbEOkg3TJb8uLG8_9AHJzG8tyu
   VlRinpnu9Vajuntw8Qxq7RRkkg-ttMDAuO_CwLwivpSxmogqo_qvYBwn3Pmli4-EGPbK
   o1B4jaJPrrhJZnuwFaURBvojJ9YOZIVYGQo2F6dObCF9ugpbhWCYn6ZCGgLsQEx4YwHg
   Qu2jiG6rZQ"
     },
     "redirect_uris": [
       "https://foodle.uninett.no/callback"
     ]
   }








Hedberg, et al.          Expires March 15, 2019                [Page 28]

                        OpenID Connect Federation         September 2018


A.6.  Unpacking the Relying Party Registration Request

   An OP that has the public part of the signing keys for both the
   SWAMID and Feide federations can now verify the signature chains all
   the way from the Metadata statement signed by UNINETT up to the FOs.
   If that works, it can then flatten the compounded metadata
   statements.

A.7.  Unpacked and Flattened Metadata Statement per FO

A.7.1.  *** ***

   {
     "application_type": "web",
     "claims": [
       "sub",
       "name",
       "email",
       "picture"
     ],
     "federation_usage": "registration",
     "id_token_signing_alg_values_supported": [
       "RS256",
       "RS512"
     ],
     "redirect_uris": [
       "https://foodle.uninett.no/callback"
     ],
     "response_types": [
       "code"
     ]
   }

A.7.2.  *** ***

















Hedberg, et al.          Expires March 15, 2019                [Page 29]

                        OpenID Connect Federation         September 2018


   {
     "application_type": "web",
     "federation_usage": "registration",
     "redirect_uris": [
       "https://foodle.uninett.no/callback"
     ],
     "response_types": [
       "code",
       "token"
     ],
     "scopes": [
       "openid",
       "email"
     ],
     "token_endpoint_auth_method": "private_key_jwt"
   }

Appendix B.  UNUSED Metadata Statement

   A metadata statement asserts metadata values about an entity (relying
   party or provider).

B.1.  Compounded Metadata Statement

B.1.1.  Basic Components

   To describe Compounded Metadata Statements, we need a way of
   describing the different components in such a statement.  These are
   the basic components:

   ms_X
      Metadata Statement signing request by X without signing keys and
      signed metadata statements.

   SK[X]
      Signing keys that belong to X

   X(MS)
      Metadata Statement signed by X

   Using these basic components, we can now describe a simple signed
   Metadata Statement as:

   A(ms_B + SK[B])

   B being the entity that requested a signature by A of B's metadata
   statement and signing keys.




Hedberg, et al.          Expires March 15, 2019                [Page 30]

                        OpenID Connect Federation         September 2018


   Creating a compounded metadata statements involves adding previously
   signed metadata statements to the request before signing it.  So, if
   we start off with C sending this signing request to B,

   (ms_C + SK[C])

   then B may want to add the signed metadata statement it received from
   A before signing.  So we first get:

                   (ms_C + SK[C] + A(ms_B + SK[B]))

   which is then signed by B before being returned to C.

   This is the resulting compounded metadata statement:

                   B(ms_C + SK[C) + A(ms_B + SK[B]))

   Here we have three entities involved: A which is the top level entity
   (the federation operator) a second level entity (B) representing a
   federation member and C which could be an entity within the
   federation like an OP or an RP owned/controlled by B.  If we assume
   that C is an RP then ms_C would typically be a relying party
   registration request and SK[C] would be the signing keys that the RP
   used to sign the JWKS placed at signed_jwks_uri.  The statement
   signed by A (ms_b + SK[B]) would contain metadata common to all RPs
   owned by the member (ms_B) and the signing key (SK[B]) that the
   member uses to sign requests from the member's RPs.

   Note that the level N requester is the level N+1 signer.

B.1.2.  Relationships between Metadata Statements

   The metadata for each entity in the federation is described by one or
   more metadata statements (for example, ms_0, ms_1, ..., ms_n). ms_0
   (the level 0 metadata statement mentioned above) would be the most
   generic, and ms_1, ..., ms_n would in turn be successively more
   specific. ms_0 would typically contain information that belongs to
   the organization, for instance, "tos_uri", "contacts" and the like,
   while ms_n would contain information that belongs to one specific
   entity like "authorization_endpoint " for an OP or "redirect_uris "
   for an RP.










Hedberg, et al.          Expires March 15, 2019                [Page 31]

                        OpenID Connect Federation         September 2018


   The following is a non-normative example of a compounded metadata
   statement.  Also note that the metadata_statement MUST be a signed
   JWT.  In this example, only the parts of the signed JWT payload
   pertinent to the example are shown.

   {
     "redirect_uris": ["https://example.com/rp1"],
     "metadata_statements": {
       'https://example.com':
         {
           "rp_scopes": ["openid", "eduperson"],
           "response_types": ["code", "code id_token"],
           "contacts": ["rp_helpdesk@example.com"],
           "redirect_uris": ["https://example.com/rp1"],
           "response_types: ["code"]
           "metadata_statements" : {
             'https://example.com':
               {
                 "logo_uri": "https://example.com/logo.jpg",
                 "policy_uri": "https://example.com/policy.html",
                 "tos_uri": "https://example.com/tos.html"
               }
            }
         }
      }
   }

Appendix C.  UNUSED Belonging to Several Federations

C.1.  Choosing a Federation

   This draft allows any entity to belong to more than one federation.
   During the provider discovery and relying party registration
   processes, the parties have to agree on which federation to use.
   Ultimately, the OP decides.

      The relying party asks for the provider information

      The OP, using some rule, may publish one or several
      "metadata_statements".  If it publishes more than one
      "metadata_statements", then they SHOULD be rooted in different
      federations.

      Based on what the OP published, the RP publishes a number of
      "metadata_statements", all rooted in federations that the OP
      belongs to.





Hedberg, et al.          Expires March 15, 2019                [Page 32]

                        OpenID Connect Federation         September 2018


      If the RP published more than one "metadata_statements", then the
      OP should/must choose one and make that known in the relying party
      registration response.  One way of doing this is described
      inSection 7.1.2.2.

C.2.  Relying Party

   An organization may be a member of more than one federation.  The RPs
   it is responsible for may be members of one or more of these.

   This is then how to deal with this.  The organization registers and
   gets metadata signed by each federation.  One extreme is that it will
   mint a new key pair for each federation, the other is that it will
   use the same key pair for all federations.  It does not matter which
   it chooses, but the end result MUST be that there is one signed RP
   registration request per signing key.  This is then published using
   "metadata_statement_uris" or "metadata_statements".

   The following is a non-normative example of an absolutely minimal
   relying party registration request sent to an OP:

   {
     "redirect_uris": ["https://example.com/rp2/callback"],
     "metadata_statement_uris": {
         https://swamid.sunet.se/":
           "https://dev.example.com/rp1/idfed/swamid.jws",
         "https://www.incommon.org":
           "https://dev.example.com/rp1/idfed/incommon.jws"
     }
   }

   As described above, when the OP receives a request like this it will
   choose which federation it will work within and then signal that by
   only returning that corresponding information in the
   "metadata_statements " / "metadata_statement_uris" in the
   registration response.















Hedberg, et al.          Expires March 15, 2019                [Page 33]

                        OpenID Connect Federation         September 2018


   The following is a non-normative example of an OP's response on the
   relying party registration request above:

   {
     "client_id": "abcdefgh",
     "client_secret": "0123456789",
     "client_id_issued_at": 1462375583,
     "client_secret_expires_at": 1462379183,
     "redirect_uris": ["https://example.com/rp2/callback"],
     "metadata_statement_uris": {
       "https://swamid.sunet.se/":
         "https://dev.example.com/rp1/idfed/swamid.jws",
     }
   }

C.3.  OpenID Provider

   An OP has the choice of whether it wants one key pair per federation,
   one key pair for everyone, or anything in between.  And, like the RP
   owner, it has to produce one signed metadata statement per key used.

   The following is a non-normative example of an OP's response to a
   provider configuration request:

     {
       "issuer": "https://foo.example.org/op/fDTowvP0slEdEAcc",
       "response_types_supported": ["code", "code id_token", "token"],
       "grant_types_supported": ["authorization_code", "implicit",
           "urn:ietf:params:oauth:grant-type:jwt-bearer"],
       "subject_types_supported": ["pairwise", "public"],
       "id_token_signing_alg_values_supported": ["RS256"],
       "metadata_statement_uris": {
         "https://swamid.sunet.se/":
           "https://foo.example.org/op/idfed/swamid.jws",
         "https://www.incommon.org":
           "https://foo.example.org/op/idfed/incommon.jws"
         "https://www.switch.ch":
           "https://foo.example.org/op/idfed/switch.jws"
         "https://www.aco.net/":
           "https://foo.example.org/op/idfed/aconet.jws"
     }

Appendix D.  UNUSED Trust Model

   The trust model is based on linking together signing keys,
   represented as JWK Sets [RFC7517].  Each signature chain is rooted in
   the trusted third party's signing keys.  By verifying these signature
   chains, the entities can establish trust in the metadata.



Hedberg, et al.          Expires March 15, 2019                [Page 34]

                        OpenID Connect Federation         September 2018


D.1.  Federation Operator

   The Federation Operator (FO) is the trusted third party.  The FO MUST
   have a globally unique identifier.  Every time it signs a metadata
   statement it MUST set "iss" to the identifier.  It will publish a
   JWKS, containing the signing keys that the FO will use for signing
   metadata submitted to it, at an HTTPS URL which server certificate
   MUST appear in a well-known Certificate Transparency log [RFC6962].
   The key IDs of the FO's signing keys MUST be globally unique.

   For the following description, this is assumed to be true: A
   federation consists of a number of members, and each member has one
   or more representatives registered with the federation.  These
   representatives are allowed to issue metadata signing requests on
   behalf of the member to the federation.  Below such a representative
   is called a Level 0 Requester (L0Req).  Within each member unless all
   entities belonging to the member are handled directly by the L0Req
   there may exist parties that are responsible for single or groups of
   entities.  Within these parties we may have further subdivisions such
   that we end up with Level 0, 1, 2, 3 or more requesters.  This
   document makes no assumption on the number of levels.

D.2.  The Building Block

   Even though we talk about a chain of trust model, the actual
   representation is as we have seen above a compounded metadata
   statement.

   The innermost metadata statement in the nest of metadata statements
   is the one that the FO has signed.  That statement MUST NOT contain
   any references to other metadata statements.  See simple signed
   metadata (Section B.1.1, Paragraph 2) above.  All other metadata
   statements in the nest MUST contain at least one reference to another
   metadata statement.  An example of this is can be seen
   inSection B.1.1, Paragraph 4.

D.3.  Constructing a Signed Metadata Statement

   These are the steps that are performed to construct a signed metadata
   statement.  A metadata signing request may be about one specific
   entity or a group of similar entities.

   1.  The "requester" constructs a signing request by collecting the
       necessary relying party or provider metadata as described
       inAppendix B.

   2.  If this is about the top most metadata statement (ms_0) then no
       metadata statement will be added to the metadata statement.  If



Hedberg, et al.          Expires March 15, 2019                [Page 35]

                        OpenID Connect Federation         September 2018


       it is a more specific metadata statement (ms_1...n) then more
       general metadata statement/-s MUST be added.  Dependent on setup
       the metadata statement can be added by the requester or the
       signer.

   3.  The metadata statement is transported to the signing party.  In
       the case of ms_0 this MUST be the FO.  If it is ms_1 it is the
       "L0Req".  If it is ms_2 it is the L1Req and so on.

   4.  The signing party verifies the information in the metadata
       statement, modifies and/or adds more information according to the
       policy before signing the statement.

   5.  Once signed by the signer the signed metadata is sent back to the
       "requester".

   An example of the construction of a compounded metadata statement.
   The Level 0 Requester (L0Req) sends a metadata statement request to
   the federation operator (FO).

   L0Req -- (ms_L0Req + SK[L0Req]) --> FO

   The FO verifies the information and if the federations policy so
   demands may add extra information.  After signing with the FO's
   signing key the signed metadata statement is returned to the L0Req.

   L0Req <-- FO(ms_L0Req + SK[L0Req]) --- FO

   Next step that happens some time later is that the L1Req sends a
   Metadata Statement signing request to the L0Req.

   L1Req -- (ms_L1Req + SK[L1Req]) --> L0Req

   The L0Req verifies the information in the request and adds the signed
   L0Req metadata.  The L0Req may also add other information to the
   Metadata Statement before it signs and returns it to the L1Req.

   L1Req <- L0Req(ms_L1Req + SK[L1Req] + FO(ms_L0Req+SK[L0Req])) - L0Req

   This was an example using 3 levels.  As said before this document
   makes no assumption as to how many levels should be used.

D.4.  Verifying the Metadata Statement

   Verifying a metadata statement, you first grab the innermost signed
   metadata statement.  If this is signed by a FO, you have the public
   part of the signing keys from then you can verify the signature of
   the metadata statement.  If the verification concludes that the



Hedberg, et al.          Expires March 15, 2019                [Page 36]

                        OpenID Connect Federation         September 2018


   signature was correct you can now take the signing keys that were
   included in the signed document and use those to verify the second
   innermost signed metadata statement.  And so on.

   Verifying the received metadata statement involves running a function
   similar to this:

   def unpack(jwt, sign_keys):
       keys = []
       pl = get_payload(jwt)
       if 'metadata_statements' in pl:
           msl = []
           for _iss, statement in pl['metadata_statements'].items():
               _ms = unpack(statement, sign_keys)
               if _ms:
                   keys.append(get_keys(_ms))
                   msl.append(_ms)
           pl['metadata_statements'] = msl
       elif 'metadata_statement_uris' in pl:
           msl = []
           for _iss, uri in pl['metadata_statement_uris'].items():
               statement = html_get(uri)
               _ms = unpack(statement, sign_keys)
               if _ms:
                   keys.append(get_keys(_ms))
                   msl.append(_ms)
           pl['metadata_statements'] = msl
       else:
           return verify_signature(ms, pl['iss'], sign_keys):

       if verify_signature(ms, pl['iss'], keys):
           return pl

   where the function get_payload unpacks the payload from the JWS
   without verifying the signature.  The function verify_signature, on
   the other hand, does verify the signature of the JWS and if
   everything is correct returns the JWS payload.

D.5.  Flattening the Compounded Metadata Statement

   Once you have a verified compounded metadata statement, you have to
   flatten it to get a useful metadata statement.  To do this you can,
   for instance, use the method outlined in Section 6








Hedberg, et al.          Expires March 15, 2019                [Page 37]

                        OpenID Connect Federation         September 2018


Appendix E.  Open Issues

   The following open issues remain to be addressed in this
   specification.

   o  How are federation operator keys retrieved?

   o  A mechanism is needed for key rotation of federation operator keys
      for long-term security and maintainability of federations.

   o  A mechanism is needed for key revocation.

   o  A mechanism may be needed for bounding key lifetimes.

   o  What is the syntax for federation identifiers?  Is it the URL of
      the root of the federation operator's metadata?

   o  Can both "metadata_statements" and "metadata_statement_uris" be
      present or are they mutually exclusive?

   o  How are signature timeouts represented?  What happens after the
      timeout is expired?

   o  Consider adding rationale explaining the rule "The number A is a
      subset of the number B if A is less or equal to B".

   o  Why is the Constructing Entity Metadata appendix not normative?  I
      believe that it should be.

   o  Change section titles "*** ***" to something meaningful.

Appendix F.  Notices

   Copyright (c) 2018 The OpenID Foundation.

   The OpenID Foundation (OIDF) grants to any Contributor, developer,
   implementer, or other interested party a non-exclusive, royalty free,
   worldwide copyright license to reproduce, prepare derivative works
   from, distribute, perform and display, this Implementers Draft or
   Final Specification solely for the purposes of (i) developing
   specifications, and (ii) implementing Implementers Drafts and Final
   Specifications based on such documents, provided that attribution be
   made to the OIDF as the source of the material, but that such
   attribution does not indicate an endorsement by the OIDF.

   The technology described in this specification was made available
   from contributions from various sources, including members of the
   OpenID Foundation and others.  Although the OpenID Foundation has



Hedberg, et al.          Expires March 15, 2019                [Page 38]

                        OpenID Connect Federation         September 2018


   taken steps to help ensure that the technology is available for
   distribution, it takes no position regarding the validity or scope of
   any intellectual property or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this specification or the extent to which any license under such
   rights might or might not be available; neither does it represent
   that it has made any independent effort to identify any such rights.
   The OpenID Foundation and the contributors to this specification make
   no (and hereby expressly disclaim any) warranties (express, implied,
   or otherwise), including implied warranties of merchantability, non-
   infringement, fitness for a particular purpose, or title, related to
   this specification, and the entire risk as to implementing this
   specification is assumed by the implementer.  The OpenID Intellectual
   Property Rights policy requires contributors to offer a patent
   promise not to assert certain patent claims against other
   contributors and against implementers.  The OpenID Foundation invites
   any interested party to bring to its attention any copyrights,
   patents, patent applications, or other proprietary rights that may
   cover technology that may be required to practice this specification.

Appendix G.  Document History

   [[ To be removed from the final specification ]]

   -05

   o  A major rewrite, introducing WebFinger, entity statements and
      more.

   -04

   o  Changed client metadata names "scopes" to "rp_scopes" and "claims"
      to "rp_claims".

   o  Added Open Issues appendix.

   o  Added additional references.

   o  Editorial improvements.

   o  Added standard Notices section, which is present in all OpenID
      specifications.

Authors' Addresses







Hedberg, et al.          Expires March 15, 2019                [Page 39]

                        OpenID Connect Federation         September 2018


   Roland Hedberg (editor)
   independent

   Email: roland@catalogix.se


   Samuel Gulliksson
   Schibsted Media Group

   Email: samuel.gulliksson@gmail.com


   Michael B. Jones
   Microsoft

   Email: mbj@microsoft.com
   URI:   http://self-issued.info/


   John Bradley
   Ping Identity

   Email: ve7jtb@ve7jtb.com
   URI:   http://www.thread-safe.com/


   Andreas Aekre Solberg
   Uninett AS

   Email: andreas.solberg@uninett.no
   URI:   https://www.linkedin.com/in/andreassolberg/




















Hedberg, et al.          Expires March 15, 2019                [Page 40]
